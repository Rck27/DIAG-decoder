#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <poll.h>
#include <time.h>

#include "all.h"

/* --- Constants --- */
#define LOG_TYPE_OFFSET 26

static const uint8_t kFrameStart[4] = {0x20, 0x00, 0x00, 0x00};
static const uint8_t kFrameEnd = 0x7e;
static const int kConnectLen = 110;
static const int kInitialSendDelayMs = 200;
static const int kBetweenSendDelayMs = 50;
static const int kPayloadCount = 54;

/* --- Dynamic Buffer Helper (replaces std::vector) --- */
typedef struct {
    uint8_t *data;
    size_t size;
    size_t capacity;
} ByteBuffer;

typedef enum {
    ROOT_UNKNOWN,
    DL_DCCH,
    UL_DCCH,
    DL_CCCH,
    UL_CCCH,
    BCCH_DL_SCH,
    PCCH,
    MCCH,
    SC_MCCH,
    BCCH_BCH

} lte_rrc_root_type_t;

typedef struct {
    const asn_TYPE_descriptor_t *td;
    lte_rrc_root_type_t root_type;
    const char *name;

} lte_rrc_root_entry_t;

static const lte_rrc_root_entry_t lte_rrc_root_table[] = {
    {
        .td = &asn_DEF_DL_DCCH_Message,
        .root_type = DL_DCCH,
        .name = "DL-DCCH"
    },
    {
        .td = &asn_DEF_UL_DCCH_Message,
        .root_type = UL_DCCH,
        .name = "UL-DCCH"
    },
    {
        .td = &asn_DEF_DL_CCCH_Message,
        .root_type = DL_CCCH,
        .name = "DL-CCCH"
    },
        {
        .td = &asn_DEF_UL_CCCH_Message,
        .root_type = UL_CCCH,
        .name = "UL-CCCH"
    },
        {
        .td = &asn_DEF_BCCH_DL_SCH_Message,
        .root_type = BCCH_DL_SCH,
        .name = "BCCH_DL_SCH"
    },
};

uint8_t  LTE_RRC_ROOT_TABLE_SIZE = (sizeof(lte_rrc_root_table) / sizeof(lte_rrc_root_table[0]));

static void decode_diag(const uint8_t *buf, size_t len)
{
   

    lte_rrc_root_type_t det_type = ROOT_UNKNOWN;
    const lte_rrc_root_entry_t *matched = NULL;
    void *decoded = NULL;

    for (size_t i = 0; i < LTE_RRC_ROOT_TABLE_SIZE; i++) {
        const lte_rrc_root_entry_t *e = &lte_rrc_root_table[i];
        void *msg = NULL;

        asn_dec_rval_t rval = uper_decode_complete(
            NULL,
            e->td,
            &msg,
            buf,
            len
        );

        if (rval.code == RC_OK &&
            rval.consumed > 10 &&
            rval.consumed <= (long)(len * 8)) {

            printf("Matched root type: %s\n",
                   e->name ? e->name : "unknown");
            printf("Consumed bits: %ld / %zu\n",
                   rval.consumed, len);

            det_type = e->root_type;
            matched  = e;
            decoded  = msg;
            asn_fprint(stdout, matched->td, decoded);
            break;
        }

        /* cleanup failed attempt */
        if (msg) {
            ASN_STRUCT_FREE(*e->td, msg);
        }
    }

    if (!matched) {
        printf("No matching RRC root type\n");
        return;
    }

    /* decoded message is now valid */
    /* TODO: process decoded */

    /* cleanup final decoded */
    ASN_STRUCT_FREE(*matched->td, decoded);
}

static void bb_init(ByteBuffer *bb) {
    bb->data = NULL;
    bb->size = 0;
    bb->capacity = 0;
}

static void bb_free(ByteBuffer *bb) {
    if (bb->data) free(bb->data);
    bb_init(bb);
}

#define RRC_OTA_SUBHDR_LEN 18   /* observed Qualcomm subheader */
#define CRC_LEN 2

static int process_payload(const uint8_t *p, size_t len){
    uint16_t plen1 = p[22] | (p[23] << 8);
    uint16_t plen2 = p[24] | (p[25] << 8);


    if (plen1 == 0 || plen1 != plen2) {
        /* not valid payload length */
        fprintf(stderr, "bad plen: %u vs %u\n", plen1, plen2);
        return -1;
    }
    size_t plen = (size_t)plen1;

    /* compute header length as total_len - payload_len if you're passing full frame len */
    if (len < plen) {
        /* definitely incomplete */
        return 0;
    }
    size_t hdr_len = len - plen; /* in your logs this was 27 or 28 */

    /* sanity checks */
    if (hdr_len + RRC_OTA_SUBHDR_LEN + CRC_LEN > len) {
        fprintf(stderr, "not enough data for subheader+crc: hdr=%zu plen=%zu len=%zu\n",
                hdr_len, plen, len);
        return 0; /* wait for more */
    }

    /* ASN start & length */
    size_t asn_start = hdr_len + RRC_OTA_SUBHDR_LEN;
    if (asn_start >= len) return -1;

    /* asn_len_raw = bytes from asn_start up to before delimiter (or up to hdr+plen) */
    size_t asn_len_raw = hdr_len + plen - asn_start; /* = plen - RRC_OTA_SUBHDR_LEN */
    if (asn_len_raw <= CRC_LEN) {
        fprintf(stderr, "asn payload too small: %zu\n", asn_len_raw);
        return -1;
    }

    size_t asn_len = asn_len_raw - CRC_LEN; /* strip CRC bytes */

    /* final bounds check */
    if (asn_start + asn_len > len) {
        fprintf(stderr, "bounds problem asn_start+asn_len > len\n");
        return 0;
    }

    /* Optionally, verify terminator 0x7e exists at hdr_len + plen - maybe hdr_len+plen == index_of_0x7e+1 */
    size_t expected_terminator_index = hdr_len + plen - 1; /* if payload includes terminator at last byte */
    if (expected_terminator_index < len && p[expected_terminator_index] != 0x7e) {
        /* tolerant: search a little forward/backward for 0x7e if needed (not shown) */
        /* But don't fail hard here â€” many frames show small variance/padding */
    }

    /* copy payload to a new buffer that you give to ASN decoder */
    uint8_t *asn_buf = malloc(asn_len);
    if (!asn_buf) { perror("malloc"); return -1; }
    memcpy(asn_buf, p + asn_start, asn_len);

    /* debug dump */
    fprintf(stderr, "hdr=%zu plen=%zu asn_start=%zu asn_len=%zu crc_last= %02x %02x term=%02x\n",
            hdr_len, plen, asn_start, asn_len,
            p[asn_start + asn_len],      /* first CRC byte */
            p[asn_start + asn_len + 1],  /* second CRC byte */
            p[expected_terminator_index]);
    
    decode_diag(asn_buf, asn_len);
    // uint16_t plen = (plen1 == plen2) ? plen1 : 0;
//     if(plen<1) return;
//     printf("size: %zu, plen %d, hdr %zu \n", len, plen, len-plen);
//     for(int i = 0; i < plen; i ++){
//         printf("%02x ", p[i]);
//     }
//     printf("\n x \n");
//    for(int i = plen; i < len; i ++){
//         if(i >= len - 3) printf("xx");
//         printf("%02x ", p[i]);
//     }

//     if(p[len-1] != 0x7e && p[0] != 0x20){
//         printf("invalid \n");
//         // exit;
//     }
//     uint8_t *asn_buf = malloc(plen);
//     if (!asn_buf) { perror("malloc"); return -1; }
//     memcpy(asn_buf, p + asn_start, asn_len);

    // for(int i = 0; i < len; i++){
    //     printf("%02x ", p[i]);
    // }
    // printf("\n");
        free(asn_buf);
    return 1;
}

static void debug_diag(const uint8_t *p, size_t len){
    printf("bit 4 - 7");
    for(int i = 4; i < 8;i++){
        printf(" %02x", p[i]);
    }
    printf("\n");

    printf("bit 8 - 11");
    for(int i = 8; i < 12;i++){
            printf(" %02x", p[i]);
        }
    printf("\n");

    printf("bit 12 - 16");
    for(int i = 12; i < 16;i++){
            printf(" %02x", p[i]);
        }
    printf("\n");

    printf("bit 16 - 19");
    for(int i = 16; i < 20;i++){
            printf(" %02x", p[i]);
        }
    printf("\n");

    printf("bit 20 - 21");
    for(int i = 20; i < 22;i++){
            printf(" %02x", p[i]);
        }
    printf("\n");

    printf("bit 22 - 25");
    for(int i = 22; i < 26;i++){
            printf(" %02x", p[i]);
        }
    printf("\n");

    printf("bit 26 - 27");
    for(int i = 26; i < 28;i++){
            printf(" %02x", p[i]);
        }
    printf("\n");

    printf("bit 28 - rest");
    for(int i = 28; i < len;i++){
            printf(" %02x", p[i]);
        }
    printf("\n");
    // for (int i = 0; i < len; i++){
    //     if(p[i] == 0x20)
    // }
}

static void bb_reserve(ByteBuffer *bb, size_t n) {
    if (bb->capacity < n) {
        size_t new_cap = (n < 64) ? 64 : n;
        uint8_t *new_data = realloc(bb->data, new_cap);
        if (!new_data) { perror("realloc"); exit(1); }
        bb->data = new_data;
        bb->capacity = new_cap;
    }
}

static void bb_append(ByteBuffer *bb, const uint8_t *bytes, size_t len) {
    if (bb->size + len > bb->capacity) {
        size_t new_cap = (bb->capacity == 0) ? 128 : bb->capacity * 2;
        if (new_cap < bb->size + len) new_cap = bb->size + len;
        uint8_t *new_data = realloc(bb->data, new_cap);
        if (!new_data) { perror("realloc"); exit(1); }
        bb->data = new_data;
        bb->capacity = new_cap;
    }
    memcpy(bb->data + bb->size, bytes, len);
    bb->size += len;
}

static void bb_append_zeros(ByteBuffer *bb, size_t n) {
    if (bb->size + n > bb->capacity) {
        size_t new_cap = (bb->capacity == 0) ? 128 : bb->capacity * 2;
        if (new_cap < bb->size + n) new_cap = bb->size + n;
        uint8_t *new_data = realloc(bb->data, new_cap);
        if (!new_data) { perror("realloc"); exit(1); }
        bb->data = new_data;
        bb->capacity = new_cap;
    }
    memset(bb->data + bb->size, 0, n);
    bb->size += n;
}

static void bb_erase_front(ByteBuffer *bb, size_t count) {
    if (count == 0) return;
    if (count >= bb->size) {
        bb->size = 0;
    } else {
        memmove(bb->data, bb->data + count, bb->size - count);
        bb->size -= count;
    }
}

/* --- Time Helper --- */
static void msleep(int ms) {
    if (ms <= 0) return;
    usleep(ms * 1000);
}

/* --- Payload Generators --- */
// Helper macro to make porting easier
#define APPEND(bb, ...) do { \
    uint8_t tmp[] = { __VA_ARGS__ }; \
    bb_append(bb, tmp, sizeof(tmp)); \
} while(0)

static void make_payload(int id, ByteBuffer *out) {
    bb_init(out);
    
    bb_reserve(out, 64); 

    switch(id) {
        case 0: APPEND(out, 0x28); bb_append_zeros(out, 11); APPEND(out, 0x40, 0x78, 0x7d, 0x01); break;
        case 1: APPEND(out, 0x29, 0x00, 0x00, 0x00, 0xff, 0xff, 0x01); bb_append_zeros(out, 9); APPEND(out, 0x01, 0x00, 0x00, 0x00); break;
        case 2: APPEND(out, 0x07, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0xff, 0xff, 0x01); bb_append_zeros(out, 13); APPEND(out, 0x01, 0x00, 0x00, 0x00, 0x0e, 0x75, 0x00, 0x00); break;
        case 3: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xda, 0x81, 0x7e); break;
        case 4: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00, 0x00, 0x0b, 0xcd, 0x7e); break;
        case 5: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x60, 0x00, 0x12, 0x6a, 0x7e); break;
        case 6: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x1d, 0x1c, 0x3b, 0x7e); break;
        case 7: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x00, 0x78, 0xf0, 0x7e); break;
        case 8: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x7c, 0x93, 0x49, 0x7e); break;
        case 9: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x08, 0x00, 0x00, 0xbe, 0xec, 0x7e); break;
        case 10: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x08, 0x01, 0x00, 0x66, 0xf5, 0x7e); break;
        case 11: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x04, 0x00, 0x00, 0x1d, 0x49, 0x7e); break;
        case 12: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x04, 0x0f, 0x00, 0xd5, 0xca, 0x7e); break;
        case 13: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x09, 0x00, 0x00, 0x62, 0xb6, 0x7e); break;
        case 14: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x0f, 0x00, 0x00, 0xbb, 0x60, 0x7e); break;
        case 15: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x63, 0xe5, 0xa1, 0x7e); break;
        case 16: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x1c, 0x95, 0x2a, 0x7e); break;
        case 17: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x0c, 0x14, 0x3a, 0x7e); break;
        case 18: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x80, 0x87, 0x32, 0x01, 0xc2, 0xc5, 0x7e); break;
        case 19: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x0f, 0x18, 0x00, 0x00, 0x17, 0xb8, 0x7e); break;
        case 20: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x0f, 0x18, 0x00, 0x01, 0x9e, 0xa9, 0x7e); break;
        case 21: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x0f, 0x2c, 0x00, 0x28, 0xea, 0x7e); break;
        case 22: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x30, 0x01, 0x00, 0x55, 0x07); bb_append_zeros(out, 133); APPEND(out, 0x08, 0x1d, 0xd7); break;
        case 23: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x30, 0x01, 0x00, 0xb9, 0x01); bb_append_zeros(out, 133); APPEND(out, 0x57, 0x30, 0x7e); break;
        case 24: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x30, 0x01, 0x00, 0xb2, 0x03, 0x00, 0x00, 0x00, 0xff, 0xff); bb_append_zeros(out, 127); APPEND(out, 0x3c, 0x49, 0x7e); break;
        case 25: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x30, 0x01, 0x00, 0x8a, 0x0b, 0x00, 0x00, 0x00, 0xff, 0xbf); bb_append_zeros(out, 127); APPEND(out, 0x67, 0xcb, 0x7e); break;
        case 26: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x30, 0x01, 0x00, 0xac, 0x1a); bb_append_zeros(out, 132); APPEND(out, 0x4b, 0xf3, 0x7e); break;
        case 27: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x30, 0x01, 0x00, 0x26, 0x02); bb_append_zeros(out, 132); APPEND(out, 0x69, 0x58, 0x7e); break;
        case 28: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x30, 0x01, 0x00, 0x26, 0x02, 0x01); bb_append_zeros(out, 131); APPEND(out, 0x48, 0xc6, 0x7e); break;
        case 29: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x30, 0x01, 0x00, 0x97, 0x07); bb_append_zeros(out, 132); APPEND(out, 0xba, 0x81, 0x7e); break;
        case 30: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x13, 0x01, 0x00, 0x55, 0x59, 0x7e); break;
        case 31: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x13, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00);
                 APPEND(out, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00);
                 APPEND(out, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
                 APPEND(out, 0x1e, 0x14, 0x7e); break;
        case 32: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x13, 0x27, 0x00, 0x08, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x00, 0x00);
                 APPEND(out, 0x1d, 0x00, 0x2f, 0x6e, 0x76, 0x2f, 0x69, 0x74, 0x65, 0x6d, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x73);
                 APPEND(out, 0x2f, 0x72, 0x66, 0x6e, 0x76, 0x2f, 0x30, 0x30, 0x30, 0x32, 0x32, 0x36, 0x30, 0x35, 0x00, 0xc6);
                 APPEND(out, 0x0f, 0x7e); break;
        case 33: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x13, 0x27, 0x00, 0x08, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00);
                 APPEND(out, 0x1e, 0x00, 0x2f, 0x6e, 0x76, 0x2f, 0x69, 0x74, 0x65, 0x6d, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x73);
                 APPEND(out, 0x2f, 0x6d, 0x6f, 0x64, 0x65, 0x6d, 0x2f, 0x6d, 0x6d, 0x6f, 0x64, 0x65, 0x2f, 0x74, 0x64, 0x73);
                 APPEND(out, 0x5f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x65, 0x66, 0x00, 0x03, 0x5c, 0x7e); break;
        case 34: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x13, 0x27, 0x00, 0x08, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00);
                 APPEND(out, 0x1f, 0x00, 0x2f, 0x6e, 0x76, 0x2f, 0x69, 0x74, 0x65, 0x6d, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x73);
                 APPEND(out, 0x2f, 0x6d, 0x6f, 0x64, 0x65, 0x6d, 0x2f, 0x6d, 0x6d, 0x6f, 0x64, 0x65, 0x2f, 0x6c, 0x74, 0x65);
                 APPEND(out, 0x5f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x65, 0x66, 0x00, 0xfd, 0x18, 0x7e); break;
        case 35: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x13, 0x27, 0x00, 0x18, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00);
                 APPEND(out, 0x20, 0x00, 0x2f, 0x6e, 0x76, 0x2f, 0x69, 0x74, 0x65, 0x6d, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x73);
                 APPEND(out, 0x2f, 0x6d, 0x6f, 0x64, 0x65, 0x6d, 0x2f, 0x6d, 0x6d, 0x6f, 0x64, 0x65, 0x2f, 0x6c, 0x74, 0x65);
                 APPEND(out, 0x5f, 0x62, 0x61, 0x6e, 0x64, 0x70, 0x72, 0x65, 0x66, 0x5f, 0x65, 0x78, 0x74, 0x6e, 0x5f, 0x36);
                 APPEND(out, 0x35, 0x5f, 0x32, 0x35, 0x36, 0x00, 0x3f, 0x92, 0x7e); break;
        case 36: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x13, 0x27, 0x00, 0x40, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00);
                 APPEND(out, 0x21, 0x00, 0x2f, 0x6e, 0x76, 0x2f, 0x69, 0x74, 0x65, 0x6d, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x73);
                 APPEND(out, 0x2f, 0x6d, 0x6f, 0x64, 0x65, 0x6d, 0x2f, 0x6d, 0x6d, 0x6f, 0x64, 0x65, 0x2f, 0x6e, 0x72, 0x5f);
                 APPEND(out, 0x6e, 0x73, 0x61, 0x5f, 0x62, 0x61, 0x6e, 0x64, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x00, 0x0a, 0x46);
                 APPEND(out, 0x7e); break;
        case 37: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x13, 0x27, 0x00, 0x40, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00);
                 APPEND(out, 0x22, 0x00, 0x2f, 0x6e, 0x76, 0x2f, 0x69, 0x74, 0x65, 0x6d, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x73);
                 APPEND(out, 0x2f, 0x6d, 0x6f, 0x64, 0x65, 0x6d, 0x2f, 0x6d, 0x6d, 0x6f, 0x64, 0x65, 0x2f, 0x6e, 0x72, 0x5f);
                 APPEND(out, 0x62, 0x61, 0x6e, 0x64, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x00, 0x32, 0x41, 0x7e); break;
        case 38: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x13, 0x27, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00);
                 APPEND(out, 0x23, 0x00, 0x2f, 0x6e, 0x76, 0x2f, 0x69, 0x74, 0x65, 0x6d, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x73);
                 APPEND(out, 0x2f, 0x6d, 0x6f, 0x64, 0x65, 0x6d, 0x2f, 0x6d, 0x6d, 0x6f, 0x64, 0x65, 0x2f, 0x75, 0x65, 0x5f);
                 APPEND(out, 0x75, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x00, 0x54, 0x17);
                 APPEND(out, 0x7e); break;
        case 39: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x13, 0x27, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00);
                 APPEND(out, 0x24, 0x00, 0x2f, 0x6e, 0x76, 0x2f, 0x69, 0x74, 0x65, 0x6d, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x73);
                 APPEND(out, 0x2f, 0x6d, 0x6f, 0x64, 0x65, 0x6d, 0x2f, 0x6c, 0x74, 0x65, 0x2f, 0x72, 0x72, 0x63, 0x2f, 0x63);
                 APPEND(out, 0x73, 0x70, 0x2f, 0x70, 0x63, 0x69, 0x5f, 0x6c, 0x6f, 0x63, 0x6b, 0x00, 0xea, 0x48, 0x7e); break;
        case 40: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x13, 0x27, 0x00, 0x04, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00);
                 APPEND(out, 0x25, 0x00, 0x2f, 0x6e, 0x76, 0x2f, 0x69, 0x74, 0x65, 0x6d, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x73);
                 APPEND(out, 0x2f, 0x6d, 0x6f, 0x64, 0x65, 0x6d, 0x2f, 0x6c, 0x74, 0x65, 0x2f, 0x4d, 0x4c, 0x31, 0x2f, 0x63);
                 APPEND(out, 0x61, 0x6d, 0x70, 0x5f, 0x62, 0x61, 0x6e, 0x64, 0x5f, 0x65, 0x61, 0x72, 0x66, 0x63, 0x6e, 0x00);
                 APPEND(out, 0x18, 0x97, 0x7e); break;
        case 41: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x13, 0x27, 0x00, 0x02, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00);
                 APPEND(out, 0x26, 0x00, 0x2f, 0x6e, 0x76, 0x2f, 0x69, 0x74, 0x65, 0x6d, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x73);
                 APPEND(out, 0x2f, 0x77, 0x63, 0x64, 0x6d, 0x61, 0x2f, 0x72, 0x72, 0x63, 0x2f, 0x77, 0x63, 0x64, 0x6d, 0x61);
                 APPEND(out, 0x5f, 0x72, 0x72, 0x63, 0x5f, 0x66, 0x72, 0x65, 0x71, 0x5f, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x69);
                 APPEND(out, 0x74, 0x65, 0x6d, 0x00, 0x48, 0xc7, 0x7e); break;
        case 42: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x13, 0x27, 0x00, 0x01, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00);
                 APPEND(out, 0x27, 0x00, 0x2f, 0x6e, 0x76, 0x2f, 0x69, 0x74, 0x65, 0x6d, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x73);
                 APPEND(out, 0x2f, 0x77, 0x63, 0x64, 0x6d, 0x61, 0x2f, 0x72, 0x72, 0x63, 0x2f, 0x77, 0x63, 0x64, 0x6d, 0x61);
                 APPEND(out, 0x5f, 0x72, 0x72, 0x63, 0x5f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x70, 0x73, 0x63, 0x5f);
                 APPEND(out, 0x6c, 0x6f, 0x63, 0x6b, 0x00, 0xc9, 0x3b, 0x7e); break;
        case 43: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x13, 0x02);
                 bb_append_zeros(out, 9);
                 APPEND(out, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x6d, 0x61, 0x6e, 0x2f, 0x70, 0x65, 0x72, 0x73, 0x69);
                 APPEND(out, 0x73, 0x74, 0x65, 0x64, 0x5f, 0x69, 0x74, 0x65, 0x6d, 0x73, 0x2f, 0x6c, 0x69, 0x6d, 0x69, 0x74);
                 APPEND(out, 0x65, 0x64, 0x5f, 0x62, 0x61, 0x6e, 0x64, 0x73, 0x00, 0x71, 0xdc, 0x7e); break;
        case 44: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x60, 0x01, 0x9b, 0x7b, 0x7e); break;
        case 45: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00);
                 APPEND(out, 0x95, 0x0c, 0x00, 0x00, 0xf0, 0x47, 0x08, 0x00, 0x60, 0x3a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x80);
                 APPEND(out, 0x00, 0x03, 0xc3, 0x53, 0x10, 0x09, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x01);
                 bb_append_zeros(out, 20);
                 APPEND(out, 0x08, 0x00, 0x0c, 0x28);
                 bb_append_zeros(out, 26);
                 APPEND(out, 0x68, 0x60, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02);
                 bb_append_zeros(out, 16);
                 APPEND(out, 0x80, 0x00, 0x00, 0x1e);
                 bb_append_zeros(out, 45);
                 APPEND(out, 0x01);
                 bb_append_zeros(out, 18);
                 APPEND(out, 0x7f, 0x02);
                 bb_append_zeros(out, 79);
                 APPEND(out, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x40);
                 bb_append_zeros(out, 24);
                 APPEND(out, 0x30);
                 bb_append_zeros(out, 93);
                 APPEND(out, 0x81, 0x93, 0x00, 0x01);
                 bb_append_zeros(out, 14);
                 APPEND(out, 0x10, 0xe3, 0x1c, 0x7e); break;
        case 46: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00);
                 APPEND(out, 0x77, 0x07, 0x00, 0x00, 0x21, 0x00, 0x61, 0x00, 0x08, 0x00, 0x02);
                 bb_append_zeros(out, 26);
                 APPEND(out, 0x3f, 0x43, 0x00, 0xa0, 0x80, 0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x21, 0x00, 0x41, 0x02, 0x00);
                 APPEND(out, 0x00, 0x00, 0x00, 0x00, 0x10);
                 bb_append_zeros(out, 10);
                 APPEND(out, 0xc1, 0x19, 0x11, 0x10, 0x06);
                 bb_append_zeros(out, 27);
                 APPEND(out, 0x2a, 0x02, 0x02, 0x00, 0x06, 0x00, 0x40, 0x00, 0x37);
                 bb_append_zeros(out, 133);
                 APPEND(out, 0x40, 0xfd, 0x21, 0x7e); break;
        case 47: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00);
                 APPEND(out, 0x5b, 0x02);
                 bb_append_zeros(out, 15);
                 APPEND(out, 0x10, 0x46, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07);
                 bb_append_zeros(out, 11);
                 APPEND(out, 0xd0, 0xbf, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01);
                 bb_append_zeros(out, 14);
                 APPEND(out, 0xb0, 0x7a, 0xcf, 0xe6, 0x77, 0xd0, 0x43, 0x0f, 0x13, 0x00, 0x00, 0x00, 0x01, 0x05, 0xef, 0xae);
                 APPEND(out, 0x7e); break;
        case 48: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00);
                 APPEND(out, 0x05, 0x04);
                 bb_append_zeros(out, 40);
                 APPEND(out, 0xff, 0x07, 0x18);
                 bb_append_zeros(out, 88);
                 APPEND(out, 0x01, 0x07, 0x5b, 0x87); break;
        case 49: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00);
                 APPEND(out, 0xc0, 0x09);
                 bb_append_zeros(out, 14);
                 APPEND(out, 0x9e, 0x00, 0x00, 0x00, 0xfe, 0x00, 0xfe, 0x04, 0xff, 0x00, 0xff, 0x00, 0x1f, 0x20, 0x00, 0x00);
                 APPEND(out, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x40, 0x04, 0x01, 0x02, 0x10, 0x60, 0x00, 0x00);
                 APPEND(out, 0xb9, 0x77, 0x0a, 0xa6, 0xb3, 0x80, 0xec, 0x78, 0x00, 0x00, 0x05, 0x02, 0x02, 0x00, 0x00, 0x00);
                 APPEND(out, 0x00, 0x00, 0x20);
                 bb_append_zeros(out, 193);
                 APPEND(out, 0x03, 0xfc, 0x3f, 0x00, 0xee, 0x19, 0x00, 0x00, 0x07, 0x78, 0x80, 0x01, 0x03, 0x03, 0x0f, 0x00);
                 APPEND(out, 0xfb, 0x87, 0x43, 0x18, 0x81, 0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x21, 0x04);
                 bb_append_zeros(out, 13);
                 APPEND(out, 0x07, 0x02, 0x00, 0xe4, 0x21, 0x80, 0x02, 0x88, 0x04, 0x00, 0xb0, 0x00, 0x00, 0xc0, 0xcc, 0xf8);
                 APPEND(out, 0x7e); break;
        case 50: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00);
                 APPEND(out, 0x1e, 0x01, 0x00, 0x00, 0x15, 0x06, 0x41, 0x00, 0xc8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01);
                 APPEND(out, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84);
                 bb_append_zeros(out, 10);
                 APPEND(out, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x28, 0x8b, 0xb5, 0x7e); break;
        case 51: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0x00, 0x81, 0x0d);
                 bb_append_zeros(out, 37);
                 APPEND(out, 0x0c);
                 bb_append_zeros(out, 10);
                 APPEND(out, 0x70, 0x00, 0x00, 0x80, 0x00, 0xc0, 0xff, 0xfc, 0x19, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x1f);
                 APPEND(out, 0x38, 0x00, 0x7c, 0x00, 0xf8, 0x9f, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x1e, 0x90);
                 bb_append_zeros(out, 32);
                 APPEND(out, 0xf3);
                 bb_append_zeros(out, 8);
                 APPEND(out, 0x0c, 0x00, 0x02, 0x00, 0x00, 0xf4, 0xc0, 0x01, 0x00, 0xc0, 0x01, 0x00, 0x00, 0xe4, 0xff, 0x03);
                 APPEND(out, 0x00, 0x02, 0x01, 0x00, 0x06, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0x10, 0x1e, 0x00);
                 APPEND(out, 0xc0);
                 bb_append_zeros(out, 14);
                 APPEND(out, 0x09);
                 bb_append_zeros(out, 9);
                 APPEND(out, 0xff, 0x3f, 0x60, 0x00, 0x01, 0x01, 0x00, 0x00, 0x80, 0xff, 0x00, 0xc0);
                 bb_append_zeros(out, 10);
                 APPEND(out, 0xe0, 0xf9, 0x0f, 0x80, 0x61, 0xc0, 0x0e, 0x00, 0x00, 0x00, 0x20, 0xfe, 0xff, 0xff, 0x43, 0x01);
                 bb_append_zeros(out, 9);
                 APPEND(out, 0x80, 0x01);
                 bb_append_zeros(out, 9);
                 APPEND(out, 0x07, 0x00, 0x00, 0x00, 0x30, 0xe8, 0x12, 0x00, 0x60, 0x00, 0x3c, 0xf8, 0xe1, 0x0d, 0x00, 0x00);
                 APPEND(out, 0x00, 0x00, 0x00, 0x01);
                 bb_append_zeros(out, 9);
                 APPEND(out, 0x03, 0x00, 0x20, 0x00, 0xc0, 0xbf, 0x00, 0xfc, 0x11, 0x00, 0x03, 0x06, 0x00, 0x7c, 0x80, 0x87);
                 APPEND(out, 0xdb, 0x0c);
                 bb_append_zeros(out, 24);
                 APPEND(out, 0x30, 0x0c, 0x80, 0xa1, 0x01, 0x00, 0x82, 0x47, 0x02, 0x80, 0xca, 0x7f, 0xf9, 0x03, 0xff, 0x00);
                 APPEND(out, 0xc6, 0x89, 0xf7, 0xfd, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c, 0xc7, 0x5f, 0x1f, 0x00);
                 APPEND(out, 0xc0, 0x03, 0x07, 0x10);
                 bb_append_zeros(out, 9);
                 APPEND(out, 0x40, 0x01, 0x00, 0x08, 0x00, 0xc5, 0x36, 0x80, 0x0d);
                 bb_append_zeros(out, 37);
                 APPEND(out, 0x71, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x48, 0x30, 0x1c, 0xe4, 0x9f, 0xf2, 0xfb, 0x13, 0x30);
                 APPEND(out, 0x08, 0xf0, 0x40, 0x0a);
                 bb_append_zeros(out, 15);
                 APPEND(out, 0x50, 0xd5, 0x7e); break;
        case 52: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x4b, 0x12, 0x33, 0x08, 0x01, 0x01, 0x00, 0x00, 0x76, 0x14, 0x7e); break;
        case 53: APPEND(out, 0x20, 0x00, 0x00, 0x00, 0x1d, 0x1c, 0x3b, 0x7e); break;
        default: break;
    }
}

/* --- Sending Helper --- */
static int send_one_with_poll(int fd, const uint8_t *p, size_t n) {
    if (!p || n == 0) return 1;
    struct pollfd wpfd;
    memset(&wpfd, 0, sizeof(wpfd));
    wpfd.fd = fd;
    wpfd.events = POLLOUT;

    (void)poll(&wpfd, 1, 250);
    
    for (int tries = 0; tries < 5; tries++) {
        ssize_t rc = send(fd, p, n, MSG_NOSIGNAL);
        if (rc == (ssize_t)n) return 1;
        if (rc < 0 && (errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK)) {
            (void)poll(&wpfd, 1, 250);
            continue;
        }
        return 0;
    }
    return 0;
}

/* --- Connection --- */
static int connect_abstract(int socktype, int connect_len) {
    int fd = socket(AF_UNIX, socktype, 0);
    if (fd < 0) return -1;

    struct sockaddr_un sa;
    memset(&sa, 0, sizeof(sa));
    sa.sun_family = AF_UNIX;

    /*
     * The address length is 110. Since sizeof(sa.sun_family) is usually 2,
     * this effectively sets the abstract socket path.
     * The socket is "abstract" because the first byte of sun_path is 0
     * (due to memset) and we aren't using a string path.
     */
    socklen_t addrlen = (socklen_t)connect_len;
    if (addrlen > sizeof(sa)) addrlen = sizeof(sa);

    if (connect(fd, (struct sockaddr *)&sa, addrlen) != 0) {
        close(fd);
        return -1;
    }
    return fd;
}

/* --- Output --- */
static void print_frame_escaped(const uint8_t *p, size_t n) {
    printf("[FRAME len=%zu] ", n);
    for (size_t i = 0; i < n; i++) printf(" %02x ", (unsigned)p[i]);
    printf("\n");
    fflush(stdout);
}

static void process_frames(ByteBuffer *buf, FILE *out_raw) {
    while (1) {
        /* 1. Find Start (0x20, 0x00, 0x00, 0x00) */
        size_t s = 0;
        int found_start = 0;
        
        while (s + 4 <= buf->size) {
            if (buf->data[s+0] == kFrameStart[0] && 
                buf->data[s+1] == kFrameStart[1] &&
                buf->data[s+2] == kFrameStart[2] && 
                buf->data[s+3] == kFrameStart[3]) {
                found_start = 1;
                break;
            }
            s++;
        }

        if (!found_start) {
            /* If buffer is getting large but no start found, trim it except last few bytes 
               to avoid missing a partial start sequence */
            if (buf->size > 3) {
                bb_erase_front(buf, buf->size - 3);
            }
            return;
        }

        /* Discard garbage before the start frame */
        if (s > 0) bb_erase_front(buf, s);

        /* 2. Find End (0x7e) starting after the header */
        size_t e = 4;
        int found_end = 0;
        while (e < buf->size) {
            if (buf->data[e] == kFrameEnd) {
                found_end = 1;
                break;
            }
            e++;
        }

        if (!found_end) {
            /* We have a start, but not an end yet. Wait for more data. */
            return;
        }

        /* 3. Extract and Process */
        size_t frame_len = e + 1;
        process_payload(buf->data, frame_len);
        // decode_diag(buf->data, frame_len);
        // print_frame_escaped(buf->data, frame_len);
        
        if (out_raw) {
            fwrite(buf->data, 1, frame_len, out_raw);
            fflush(out_raw);
        }

        /* Remove processed frame */
        bb_erase_front(buf, frame_len);
    }
}

static void usage(const char *prog) {
    fprintf(stderr, "Usage: %s [-o OUT_FILE]\n", prog);
}

int main(int argc, char **argv) {
    const char *out_path = NULL;
    FILE *out_raw = NULL;

    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-o") == 0 && i + 1 < argc) {
            out_path = argv[++i];
        } else {
            usage(argv[0]);
            return 1;
        }
    }

    if (out_path) {
        out_raw = fopen(out_path, "wb");
        if (!out_raw) {
            perror("fopen");
            return 1;
        }
    }

    /* Connect */
    printf("Connecting...\n");
    int fd = connect_abstract(SOCK_SEQPACKET, kConnectLen);
    if (fd < 0) {
        perror("connect failed");
        if (out_raw) fclose(out_raw);
        return 1;
    }
    printf("Connected to fd %d.\n", fd);

    /* Initial Wait */
    msleep(kInitialSendDelayMs);

    /* Send Loop */
    ByteBuffer payload;
    bb_init(&payload);

    for (int i = 0; i < kPayloadCount; i++) {
        make_payload(i, &payload);
        
        if (!send_one_with_poll(fd, payload.data, payload.size)) {
            fprintf(stderr, "Failed to send payload %d\n", i);
        } else {
            printf("Sent payload %d (%zu bytes)\n", i, payload.size);
        }
        
        msleep(kBetweenSendDelayMs);
    }
    bb_free(&payload);
    printf("All payloads sent. Entering receive loop...\n");

    /* Receive Loop */
    ByteBuffer recv_buf;
    bb_init(&recv_buf);
    bb_reserve(&recv_buf, 4096);

    struct pollfd pfd;
    memset(&pfd, 0, sizeof(pfd));
    pfd.fd = fd;
    pfd.events = POLLIN;

    uint8_t temp[4096];

    while (1) {
        int prc = poll(&pfd, 1, 250); // 250ms timeout
        if (prc < 0) {
            if (errno == EINTR) continue;
            perror("poll");
            break;
        }
        if (prc == 0) continue;

        if (pfd.revents & POLLIN) {
            ssize_t n = recv(fd, temp, sizeof(temp), 0);
            if (n < 0) {
                if (errno == EINTR) continue;
                perror("recv");
                break;
            }
            if (n == 0) {
                fprintf(stderr, "Socket closed by peer.\n");
                break;
            }

            bb_append(&recv_buf, temp, (size_t)n);
            process_frames(&recv_buf, out_raw);
        }
    }

    bb_free(&recv_buf);
    close(fd);
    if (out_raw) fclose(out_raw);

    return 0;
}